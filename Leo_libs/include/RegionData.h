#ifndef REGIONDATA_H_
#define REGIONDATA_H_

#include <iostream>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <utility>
#include <cstddef>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <fstream>
#include <boost/filesystem.hpp>

using namespace std;
namespace fs = boost::filesystem;

class RegionData 
{

public:
    // Member functions
    RegionData() :
        ori_image(),ori_map(),image(), map(), xRes(1.0), yRes(1.0),
        transform(cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0)),
        invertTransform(cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0)),
        hasRotated(false), topLeftWorldLatitude(INVALID_DEGREE_VALUE),
        topLeftWorldLongitude(INVALID_DEGREE_VALUE) {};

    // This function loads the raw world image (i.e. Satellite view), the
    // binary world map (i.e. for computing the BCD), and auxiliary GCS
    // information
    //
    // E.g.: loadWorld("./image.png") assumes the following files exist:
    // - "./image.png": raw world image
    // - "./image.map.png": binary world map
    // - "./image.wf": world file, generated by Procerus MapMaker
    void loadWorld(std::string filename) throw (const std::string&);

    // Loads latitude and longitude data from .wf file
    void parseWorldFile(std::string filename) throw (const std::string&);

    bool empty();

    cv::Mat rotateImage(const cv::Mat& source, double angle,
            cv::Point2f src_center);

    cv::Mat rotateImage(const cv::Mat& source, const cv::Mat& newTransform,
            double width, double height);

    std::pair<double, cv::Point2f> computeAlignmentToObstacles();

    std::pair<double, cv::Point2f> computeAlignmentToFreespace();

    // Utility macro to rotate both the world and the map
    // NOTE: angle is in degrees, IN RIGHT HAND COORD SYSTEM!!!
    inline void rotateAllData(double angle, cv::Point2f src_center)
    {
        image = rotateImage(ori_image, angle, src_center);
        map = rotateImage(ori_map, angle, src_center);
    };
    inline void rotateAllData(double angle)
    {
        rotateAllData(angle, cv::Point2f(ori_image.cols/2.0,
                    ori_image.rows/2.0));
    };
    inline void rotateAllData(std::pair<double, cv::Point2f> angle_ctr)
    {
        rotateAllData(angle_ctr.first, angle_ctr.second);
    };
    inline void rotateAllData(const cv::Mat& newTransform, double width,
            double height)
    {
        image = rotateImage(ori_image, newTransform, width, height);
        map = rotateImage(ori_map, newTransform, width, height);
    };

    std::pair<double, double> transformPoint(double xPixel, double yPixel) {
        double *data = (double*) transform.data;
        return std::make_pair(xPixel*data[0] + yPixel*data[1] + data[2],
                xPixel*data[3] + yPixel*data[4] + data[5]);
    };
    std::pair<double, double> invertTransformPoint(double xPixel,
            double yPixel)
    {
        double *data = (double*) invertTransform.data;
        return std::make_pair(xPixel*data[0] + yPixel*data[1] + data[2],
                xPixel*data[3] + yPixel*data[4] + data[5]);
    };

    // Same as transformPoint, except does not shift by offsets
    std::pair<double, double> rotateVector(double xPixel, double yPixel) {
        double *data = (double*) transform.data;
        return std::make_pair(xPixel*data[0] + yPixel*data[1],
                xPixel*data[3] + yPixel*data[4]);
    };
    std::pair<double, double> invertRotateVector(double xPixel, double yPixel)
    {
        double *data = (double*) invertTransform.data;
        return std::make_pair(xPixel*data[0] + yPixel*data[1],
                xPixel*data[3] + yPixel*data[4]);
    };

    void clear() 
    {
        ori_image = cv::Mat();
        ori_map = cv::Mat();
        image = cv::Mat();
        map = cv::Mat();

        xRes = 1.0;
        yRes = 1.0;
        transform = cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0);
        invertTransform = cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0);
        hasRotated = false;
    };

    // Static functions
    static bool solveQuadraticEquation(double A, double B, double C,
            double &r1, double &r2);

    cv::Mat getImage();
    cv::Mat getMap();
    cv::Mat getOriginalImage();
    cv::Mat getOriginalMap();

    // Member fields
    cv::Mat ori_image;
    cv::Mat ori_map;
    cv::Mat image; // raw world image
    cv::Mat map; // black = obstacle, white = free space
    double xRes; // units: meter / pixel
    double yRes; // units: meter / pixel
    cv::Mat transform;
    cv::Mat invertTransform; // to get the original pixel location, use this.
    bool hasRotated;
    std::string loadWorldFilename;

    // Constants
    const static unsigned char BLACK = 0;
    const static unsigned char WHITE = 255;

    double topLeftWorldLatitude;
    double topLeftWorldLongitude;

    const static float INVALID_DEGREE_VALUE = 361.0;
};


#endif /* REGIONDATA_H_ */
